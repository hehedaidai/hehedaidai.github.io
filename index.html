<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>不被舍弃的前端需要知道些什么---part one by hehedaidai</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">不被舍弃的前端需要知道些什么---part one</h1>
      <h2 class="project-tagline">乐何的前端花园</h2>
    </section>

    <section class="main-content">
      <p>事实上，在工作中，有多少经验，和你面试时是否会被pass，有的时候还真的不一定能匹配上。
所以，我总结，面试那就是相亲，你要180，你要面善，你要答对要点，你要态度端正，你要勤恳……总之，你要看起来"好"
这是现实的。</p>

<p>不管你在上家公司，是技术奇葩，能在凌晨2、3点钟精力十足的解决bug，并以一种程序不上线绝不回家的精力努力奋战；</p>

<p>还是你在上家公司，是耐心达人，能在需求变更的50多次，却仍然能够笑脸盈盈的，又提交了一份新版本的试错页面；</p>

<p>还是你在上家公司，是忠犬八公，能在老板一而再再而三的拖欠 或者降薪的情况下，把工作完美交工，而这次的离开，是因为老板开不下去了……</p>

<p>我都想说，以下的知识，面试时，你一定要有感情的完美的答出，你才算是一名合格的前端</p>

<h2>
<a id="一关于html5基础" class="anchor" href="#%E4%B8%80%E5%85%B3%E4%BA%8Ehtml5%E5%9F%BA%E7%A1%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>一.关于html5基础</h2>

<p>虽然和html之前的版本差不多，但是出于对，面试官提出"你会html5么？"这一问题的尊重，请你至少阐述5个方面,html5的3~5个支持的新特性。</p>

<p>参考解题思路：</p>

<p>目前html5的新特性，标准浏览器都支持（IE9+）</p>

<p>1&gt;html5最好的优势是跨平台</p>

<p>2&gt;webapp不需要下载</p>

<p>添加了</p>

<p>1.canvas元素</p>

<p>2.媒介元素 (video和radio)</p>

<p>3.本地离线存储支持 (localstorage永久|sessionstorage)</p>

<p>4.比原先的标签更加分散和清晰 (article,footer,header,nav)</p>

<p>5.新的表单元素属性，比如data,time,Email,url,search</p>

<h2>
<a id="二关于css3基础" class="anchor" href="#%E4%BA%8C%E5%85%B3%E4%BA%8Ecss3%E5%9F%BA%E7%A1%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>二.关于CSS3基础</h2>

<p>必要性同上。这两个都不能描述 个大概，还面霸？直接面罢了。。。</p>

<p>添加了</p>

<p>1.css3选择器</p>

<p>ul li:nth-child(odd){}//odd:奇数;even:偶数</p>

<p>2.Font-face特性</p>

<p>3.word-wrap&amp;Text-overflow样式</p>

<p>4.text-decoration文字渲染(-webkit-text-fill-color:black;-webkit-text-stroke-color:red;-webkit-text-stroke-width:2.75px)
                         文字内部填充色|文字边界填充色|文字边界宽度</p>

<p>5.CSS3的多列布局(-webkit-column-count:3;-webkit-column-rule:1px solid #bbb;-webkit-column-gap:2em;)
                布局几列|列与列之间的间隔条的样式|列与列之间的间隔</p>

<p>6.边框和颜色(颜色的透明度rgba(255,0,0,0.75)|HSL的透明度hsla(112,72%,33%,0.68);边框圆角：border-radius:15px);</p>

<p>7.渐变效果 左到右(background-image:-webkit-gradient(linear,0% 0% 100% 0%,from(#fff),to(#000));)</p>

<pre><code> 复杂线性渐变(background-image:-webkit-gradient(linear,0% 0% 100% 0%,from(#2A8BBE),color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E))

     径向渐变(background-image:-webkit-gradient(radial,50 50,50,50 50,0,from(black),color-stop(0.5,red),to(blue));)
</code></pre>

<p>8.阴影和反射 (text-shadow:5px 2px 6px rgba(64,64,64,0.5);box-shadow:3px 3px 3px rgba(0,64,128,0.3);)</p>

<pre><code>        (-webkit-box-reflect:below 10px;反射在元素下方的10px的地方)
</code></pre>

<p>9.背景效果(background-clip:确定背景画区;background-origin:确定背景的位置;background-size:100%;)</p>

<pre><code>      (多背景图片:background:url(),url();background-break控制背景在不同盒子中显示)
</code></pre>

<p>10.盒子模型 (父级div display:-webkit-box;display:-moz-box;--&gt;定义盒子模型;-webkit-box-orient:horizontal;--&gt;水平排列盒子模型)</p>

<pre><code>        (子级div 追加flex -webkit-box-flex:1;-moz-box-flex:2)
</code></pre>

<p>11.transtions:有tansition-property:指定过渡的性质;transition-duration:指定过滤的持续时间;transition-delay:用于制定延迟过滤时间，transtion-timing-function:指定过滤类型</p>

<p>transforms:指拉伸、压缩、旋转、偏移等变换</p>

<p>animation:动画（-webkit-animation-name:anim1;-webkit-animation-duration:1.5s;-webkit-animation-iteration-count:4;-webkit-animation-direction:alternate;-webkit-animation-timing-function:ease-in-out;</p>

<pre><code>             (动画名、持续时间、重复次数、方向、变化模式）
</code></pre>

<h2>
<a id="三http协议" class="anchor" href="#%E4%B8%89http%E5%8D%8F%E8%AE%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>三、HTTP协议</h2>

<p>可以说的方面有：URL、http请求、响应、消息报头、相关</p>

<p>1.httpURL</p>

<p>URL格式 http://host[":"port][abs_path]</p>

<pre><code>  http表示确定通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址;port表示使用的端口号,缺省使用80；abs_path请求资源的URI,如果没有，用/，浏览器可自动
</code></pre>

<p>2.http请求</p>

<p>由三部分:请求行、消息报头、请求正文</p>

<p>---&gt;请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF  </p>

<p>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>

<p>---&gt;请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>

<p>GET     请求获取Request-URI所标识的资源</p>

<p>POST    在Request-URI所标识的资源后附加新的数据</p>

<p>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</p>

<p>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</p>

<p>DELETE  请求服务器删除Request-URI所标识的资源</p>

<p>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</p>

<p>CONNECT 保留将来使用</p>

<p>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>

<p>3.http响应</p>

<p>--&gt;在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p>

<p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>

<p>--&gt;状态行格式如下：</p>

<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>

<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p>

<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>

<p>1xx：指示信息--表示请求已接收，继续处理</p>

<p>2xx：成功--表示请求已被成功接收、理解、接受</p>

<p>3xx：重定向--要完成请求必须进行更进一步的操作</p>

<p>4xx：客户端错误--请求有语法错误或请求无法实现</p>

<p>5xx：服务器端错误--服务器未能实现合法的请求</p>

<p>常见状态代码、状态描述、说明：</p>

<p>200 OK      //客户端请求成功</p>

<p>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</p>

<p>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p>

<p>403 Forbidden  //服务器收到请求，但是拒绝提供服务</p>

<p>404 Not Found  //请求资源不存在，eg：输入了错误的URL</p>

<p>500 Internal Server Error //服务器发生不可预期的错误</p>

<p>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>

<p>eg：HTTP/1.1 200 OK （CRLF）</p>

<p>--&gt;响应报头后述</p>

<p>--&gt;响应正文就是服务器返回的资源的内容 </p>

<p>4.消息报头</p>

<p>--&gt;HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就
是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</p>

<p>--&gt;HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。
每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</p>

<p>另： 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等</p>

<h2>
<a id="四tcp三次握手" class="anchor" href="#%E5%9B%9Btcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>四、TCP三次握手</h2>

<p>在TCP/IP协议中，为了提供可靠的连接服务，采用三次握手建立一个连接</p>

<p>第一次 建立连接 客户端先发送syn包</p>

<p>第二次 服务器收到syn包 为了确认客户端的syn包，故发送syn+ack包</p>

<p>第三次 客户端收到syn+ack包 向服务端发送ack包 ，完成三次握手</p>

<h2>
<a id="五闭包" class="anchor" href="#%E4%BA%94%E9%97%AD%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>五、闭包</h2>

<p>简单的说，闭包就是返回了一个函数</p>

<p>但是其实，函数本身是闭包，返回的函数也是闭包</p>

<p>闭包的真谛是，函数内部声明的变量，外部无法访问，但是却可以操作变量的属性
             闭包调用了一些本应销毁的变量 ，是会一直留存，直到闭包作用域内部的执行完毕，才会释放。</p>

<h2>
<a id="六css模块化" class="anchor" href="#%E5%85%ADcss%E6%A8%A1%E5%9D%97%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>六、css模块化</h2>

<p><a href="https://github.com/import" class="user-mention">@import</a> 是css模块化的利器。</p>

<p>/**</p>

<ul>
<li>xxx页面入口样式文件style.css
*/</li>
</ul>

<p><a href="https://github.com/import" class="user-mention">@import</a> './utils/base.css';
/<em>页面基础框架（骨架）</em>/</p>

<p><a href="https://github.com/import" class="user-mention">@import</a> './mods/layout.css';</p>

<p><a href="https://github.com/import" class="user-mention">@import</a> './mods/header.css';</p>

<p><a href="https://github.com/import" class="user-mention">@import</a> './mods/nav.css';</p>

<p>/<em>首页焦点图</em>/</p>

<p><a href="https://github.com/import" class="user-mention">@import</a> './mods/flash-pic.css';</p>

<p>………这里省略诸多模块………</p>

<p><a href="https://github.com/import" class="user-mention">@import</a> './mods/footer.css';</p>

<p>将style.css中混乱的样式 划分成了一个一个的子文件</p>

<p>另还有一种就是使用less,less更多的是把css编程化。</p>

<h2>
<a id="七css及js打包" class="anchor" href="#%E4%B8%83css%E5%8F%8Ajs%E6%89%93%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>七、css及js打包</h2>

<p>1.首先安装nodeJs</p>

<p>2.安装grunt一系列的插件，命令如下：</p>

<p>npm install grunt -g  //安装grunt,-g全局变量 </p>

<p>npm install grunt-cli -g //安装grunt命令行 </p>

<p>npm install grunt --save-dev  //安装grunt,--save-dev保存到安装目录 </p>

<p>npm install grunt-cli --save-dev //安装grunt命令行 </p>

<p>npm install grunt-contrib-jshint --save-dev //js语法检测插件 </p>

<p>npm install grunt-contrib-concat --save-dev //js合并插件 </p>

<p>npm install grunt-contrib-uglify --save-dev //js压缩插件 </p>

<p>npm install grunt-contrib-cssmin --save-dev //CSS压缩插件 </p>

<p>3.创建工作目录</p>

<p>node_modules里面包含了上面安装的插件</p>

<p>--&gt;新建
Gruntfile.js |  package.json</p>

<p>--&gt;package.json
{
  "name": "demo",
  "file": "zepto",
  "version": "0.1.0",
  "description": "demo",
  "license": "MIT",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.6.3",
    "grunt-contrib-uglify": "~0.2.1",
    "grunt-contrib-requirejs": "~0.4.1",
    "grunt-contrib-copy": "~0.4.1",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-strip": "~0.2.1"
  },
  "dependencies": {
    "express": "3.x"
  }
}</p>

<p>Gruntfile.js
module.exports = function (grunt) { 
 // grunt配置 
 grunt.initConfig({ 
 pkg: grunt.file.readJSON('package.json'), 
 concat: { 
  options: { 
  separator: ';'
  }, 
  dist: { 
  src: ['js_s/function.js', 'js_s/jquery.validate.js'], 
  dest: 'js_d/main.js' //合并不压缩 
  } 
 }, 
 uglify: { 
  options: { 
  banner: '/<em>! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' //文件顶部的注释，可自定义 
  }, 
  build: { //将package.json中的file对应的文件，进行压缩并重命名 
  src: 'js_s/&lt;%= pkg.file %&gt;.js',  //注意空格，官方配置例子是pkg.name 
  dest: 'js_d/&lt;%= pkg.file %&gt;.min.js' //注意空格，官方配置例子是pkg.name 
  }, 
  buildall: {//将js_s文件夹下的所有js文件，压缩后，放到js_d文件夹中，文件名不变 
  files: [{ 
  expand:true, 
  cwd:'js_s',//js目录下 
  src:'</em><em>/</em>.js',//所有js文件 
  dest: 'js_d'//输出到此目录下 
  }] 
  }, 
  hebin: {//将function.js和jquery.validate.js，合并,并压缩成main.min.js 
  files: { 
   'js_d/main.min.js': ['js_s/function.js', 'js_s/jquery.validate.js'] 
  } 
  }, 
  ymain: {//将main.js压缩成main1.min.js 
  src: 'js_s/main.js', 
  dest: 'js_d/main1.min.js'
  } 
 }, 
 jshint: { //检查，function.js是不是有语法错误 
  all: ['js_s/function.js'] 
 }, 
 cssmin: { 
  combine: { 
    files: { //将css_s文件夹下的css文件合成一个 
     'css_d/main.css': ['css_s/<em>.css'] 
    } 
   }, 
  minify: { 
    options: { 
     keepSpecialComments: 0, /</em> 删除所有注释 <em>/ 
     banner: '/</em> minified css file <em>/'
    }, 
    files: { //单个CSS文件压缩 
     'css_d/index.min.css': ['css_s/index.css'] 
    } 
   }, 
  test: {//按文件夹下的所有CSS文件，压缩后，放到新的文件夹中，文件名不变 
    files: [{ 
   expand:true, 
   cwd:'css_s',//css目录下 
   src:'</em><em>/</em>.css',//所有css文件 
   dest: 'css_d'//输出到此目录下 
   }] 
   } 
  } 
 }); 
 // 加载插件 
 grunt.loadNpmTasks('grunt-contrib-uglify'); 
 grunt.loadNpmTasks('grunt-contrib-concat'); 
 grunt.loadNpmTasks('grunt-contrib-jshint'); 
 grunt.loadNpmTasks('grunt-contrib-cssmin'); </p>

<p>// 是否调用插件功能 
 //grunt.registerTask('default', ['concat','uglify','jshint','cssmin']); 
 // grunt.registerTask('default', ['uglify']); 
 // grunt.registerTask('default', ['concat']); 
 //grunt.registerTask('default', ['jshint']); 
 grunt.registerTask('default', ['cssmin']); //CSSMIN插件的功能能用，其他功能都不起作用 
}
如此配置，将要压缩的文件放到 js_d 、css_d,压缩后生成的文件放到js_s、css_s文件夹中，
然后，最后在命令行中执行一句话--&gt;grunt 就可以啦。简单吧</p>

<h2>
<a id="八关于less还有sass" class="anchor" href="#%E5%85%AB%E5%85%B3%E4%BA%8Eless%E8%BF%98%E6%9C%89sass" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>八.关于LESS还有SASS</h2>

<p>--&gt;sass是最早的css预处理语言，有比less更为强大的功能。但因其一开始的缩进式语法并不能被开发者们接受，所以使用率不高，不过由于其强大的功能和Ruby on Rails 的大力推动，逐渐被更多开发者使用。</p>

<p><a href="http://www.sass.hk/getstarted.html">http://www.sass.hk/getstarted.html</a></p>

<p>--&gt;LESSCSS是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS的赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。</p>

<p><a href="http://www.1024i.com/demo/less/">http://www.1024i.com/demo/less/</a></p>

<h3>
<a id="特点" class="anchor" href="#%E7%89%B9%E7%82%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>特点：</h3>

<p>--&gt;LESS环境较Sass简单</p>

<p>--&gt;LESS使用貌似也比Sass简单</p>

<p>--&gt;从功能出发，Sass较Less略强大一些</p>

<p>--&gt;Sass在市面上有一些成熟的框架，如Compass</p>

<h2>
<a id="九js的-oop" class="anchor" href="#%E4%B9%9Djs%E7%9A%84-oop" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>九、js的 OOP</h2>

<p>对象化编程-------简单地去理解就是把javascript能涉及到的范围分成各种对象，对象下面再次划分对象。编程出发点多是对象，或者说基于对象。所说的对象既包含变量，网页，窗口等等
<a href="http://www.cnblogs.com/yahue/p/3631994.html">http://www.cnblogs.com/yahue/p/3631994.html</a></p>

<p>MVC:这是常见的一种设计模式
<a href="http://www.mamicode.com/info-detail-427942.html">http://www.mamicode.com/info-detail-427942.html</a></p>

<p>MVVM:像angularJs,vueJs等都属于这一类</p>

<p>大叔博客：<a href="http://www.cnblogs.com/lori/p/4705191.html">http://www.cnblogs.com/lori/p/4705191.html</a></p>

<p>使用angularJs绑定数据的思路：</p>

<p>*创建控制器，$http使用post|get请求到 数据，保存对象中。
*页面绑定数据。
*页面操作数据触发控制器中的事件，然后$http上报+调用后台的相关编辑或者删除的方法。</p>

<h2>
<a id="十dom" class="anchor" href="#%E5%8D%81dom" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>十、DOM</h2>

<p>这个必须要知道 参考文章<a href="http://www.cnblogs.com/yexiaochai/p/3567597.html">http://www.cnblogs.com/yexiaochai/p/3567597.html</a></p>

<p>DOM2级事件规定事件包括三个阶段：</p>

<p>① 事件捕获阶段</p>

<p>② 处于目标阶段</p>

<p>③ 事件冒泡阶段</p>

<h2>
<a id="十一前端性能优化的建议包含移动端" class="anchor" href="#%E5%8D%81%E4%B8%80%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%BB%BA%E8%AE%AE%E5%8C%85%E5%90%AB%E7%A7%BB%E5%8A%A8%E7%AB%AF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>十一、前端性能优化的建议（包含移动端)</h2>

<p><a href="http://blog.csdn.net/playboyanta123/article/details/45315809">http://blog.csdn.net/playboyanta123/article/details/45315809</a></p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
